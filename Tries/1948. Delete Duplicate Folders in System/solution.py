class TrieNode:
    def __init__(self, folder=""):
        self.next = {}
        self.folder = folder

class Solution:
    def deleteDuplicateFolder(self, paths: List[List[str]]) -> List[List[str]]:
        root = TrieNode("/")
        
        # construct Trie
        for path in paths:
            curr = root
            for c in path:
                if c not in curr.next:
                    curr.next[c] = TrieNode(c)
                curr = curr.next[c]
        
        # serialization / hashing
        node2key = defaultdict(int)
        key2id = defaultdict(int)
        count = defaultdict(int)
        def serialize(root): # DFS
            key = ""
            # !!! important, we need sorting or our path will be generated by random order even it should be consistent
            # root = ["a", "b"] & root' = ["b", "a"] -> root & root' should be duplicate and their key should be the same
            for c in sorted(root.next.keys()):
                 key += str(serialize(root.next[c])) + "$" + root.next[c].folder + "$" 

            node2key[root] = key
            count[key] += 1
            if count[key] == 1:
                key2id[key] = len(key2id)+1
            
            return key2id[key]
        serialize(root)

        # backtracking valid node
        res = []
        def dfs(node, path):
            key = node2key[node]
            
            # based on our serialization, leaf node's child node is None
            # thus, leaf node's key would be empty.
            # -> every leaf node's key would be the same, i.e. empty string
            # therefore, countKey[leaf node] = # of leaf nodes
            # if we got more than 2 leaf node, we'll see every leaf node as duplicate
            # this is wrong
            if key and count[key] >= 2: return
            
            if node.folder != "/":
                path.append(node.folder)
                res.append(path.copy())
            
            for ch in node.next:
                dfs(node.next[ch], path)
                
            # backtracking
            if node.folder != "/":
                path.pop()
        
        dfs(root, [])
        return res