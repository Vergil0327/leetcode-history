# Intuition

p means how many meaningful bits. p digits got value at most
if p = 3, nums = [001, 010, 011, 100, 101, 110, 111] => 3 digits at most

our target is to minimize the product => the more 00..001 we have, the smaller the product is.
必且必須non-zero, 所以每一個數必須至少擁有一個1-bit

example 3.

001
010
011
101
100
110
111

相同bit-position可以互換, 所以盡可能先把1都移到一端會變成

000
000
000
111
111
111
111

必且就像前面講的, 越多0000...1會使得乘積越小
所以把一些1移上去變成

001
001
001
110
110
110
111

而這就是我們所能擁有得最多的001

如果有更多位數的, 就一樣概念把每個數透過operation移成兩個極端
由於是乘積兩個極端的乘積會比中間乘積來得小

ex. sum = 10 => 5*5 > 4*6 > 1*10

000..000
000..000
000..000
111..111 2^(p-1)
111..111
111..111
111..111 
如果高位第一位是1,  後面會有(p-1)位, 所以會有2^(p-1)個 1 X X X X X X X X
同理高位的第二位1, 也會有 2^(p-1)個 X 1 X X X X X
所以如果把每一位數的1都挪到一起組成1 1 1 1 1 1 1 1 1 1 
總共就會有2^(p-1)個 1 1 1 1 1 1 1 1 1 1 

同樣, 我們也會有2^(p-1)個0 0 0 0 0 0 0 0 0 0 0
但由於我們範圍是[1, 2^p-1], 所以不包括000..000, 而是從000.0001開始
所以實際上有`2^(p-1) - 1`個 0000...000

而我們的最佳解就是把這些000...000都組成000...0001, 並將所有數相乘
所以我們會有:
- `2^(p-1) - 1` 個 00000...0001 = 1
- `2^(p-1) - 1` 個 1111....1110
- 1 個 11111...11111
這些相乘就是答案