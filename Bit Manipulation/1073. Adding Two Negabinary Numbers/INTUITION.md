# Intuition

由於負數的次方會是正負數交替出現
所以我們分開討論看看加法情況會如何

0  1  2   3    4   5   6
1 -2  4  -8   16  -32  64

正數:
[1]+[1] = 1+1 = 2 = [110]
[100]+[100] = 4+4 = 8 = [11000]
=> 後兩位bit各加1

負數
[10]+[10] = -2 + -2 = -4 = [1100]
[1000]+[1000] = -8 + -8 = -16 = [110000]
=> 後兩位bit各加1

```
Example 1.

  11111
+   101

-> reverse, 由左往右遍歷

  11111
+ 101
  00001 expected

[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] => 其實為 0 => [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 1, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0]
```

所以其實我們兩個arr翻轉一下, 依照每個bit位相加
當前`res[idx]`bit位為`(res[idx] + arr1[i] + arr2[j])%2`
而進位則為`res[idx+1] += (arr1[i] + arr2[j])//2`以及`res[idx+2] += (arr1[i] + arr2[j])//2`

並且判斷一下, 每當`res[idx] == res[idx+1] * 2`, 代表兩者相加為0, 等同於`res[idx] = res[idx+1] = 0`

arr1, arr2最多1000位數, 所以我們的答案`res`多開幾個空間
最後在移除leading zeros即可

# Other Solution

或者我們也可以不要翻轉, 利用`arr.pop()`從末尾加回來即可

當前bit位為`carry + arr1.pop() + arr2.pop() = carry'`
那麼加總後的當前bit位為`carry' % 2`
由於正負號會輪次翻轉, 下次的carry相當於是:`carry = -(carry' // 2)`

```
ex. 

 11 
+ 1

-1 -> carry
 11
 01
 00
```

但要注意, 我們bit位上不可為-1, 所以我們要持續加到`arr1`, `arr2` 為空且`carry=0`

```py
while arr1 or arr2 or carry:
    # ...
```
