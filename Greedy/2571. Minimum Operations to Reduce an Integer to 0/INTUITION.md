# Greedy with bit manipulation

## Intuition

我們可以仔細看一下example1跟example2
我們的目標是讓n透過加減變成一個2的倍數，然後依次盡可能地扣除

如果把它轉成二進制表示的話，就很明顯了
我們的最佳策略顯然就兩種，如果我們有連續的1的話，例如bits=`111`我們可以加上1讓他往高位進位變成`1000`
如果我們bits只有一個`1`，那我們就直接扣掉讓他變成`0`

我們可以透過這兩種策略來達到找出最佳步走

```
example 1
n = 39 -> 100111
n = 40 -> 101000
n = 32 -> 100000

example 2
n = 54 -> 110110
n = 56 -> 111000
n = 64 -> 1000000
```

所以在把所有的1-bit變為零之前，我們就持續以greedy的方式執行這兩個策略
首先當低位是0時，直接右移
再來我們算看看有多少個連續的1-bit
如果只有一個，直接右移一個步驟
如果大於一個，那就把這些連續的1-bit往高位進位然後右移
```py
while n:
    while n&1 == 0:
        n >>= 1

    i = 0
    while (n>>i)&1:
        i += 1

    if i == 1:
        n>>= i
    else:
        n |= (1<<i)
        n >>= i
```