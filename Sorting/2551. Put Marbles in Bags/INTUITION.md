# Intuition

要將一個`nums` array 分成 `k` 個subarray，我們總共需要切`k-1`刀來分
如果切在第`i`位置，切下去後所得到的分數為`weights[i] + weights[i+1]`

由於一定得分成`k`個subarray，因此最多就`k-1`刀，我們僅需要關注每一刀所獲得的分數即可

每一刀的分數為`weights[i]+weights[i+1]`，把全部可能找出來並做排序

前`k-1`大的分數加總 扣掉 前`k-1`小的分數加總後，即為所求
至於頭跟尾的分數由於兩種情況都有，自然會扣掉

ex. Input: weights = [1,3,5,1], k = 2

切在[[1] | [3,5,1]]分數為 (1+1) + (3+1) = 6
切在[[1,3] | [5,1]]分數為 (1+3) + (5+1) = 10

最大差值為 10-6，會發現最高分數跟最小分數都包含首尾的1，會自然扣掉
所以只要關注差值 (5+3) - (3+1) = 4 即可

# Complexity

- time complexity
$$O(nlogn)$$

- space complexity
$$O(n)$$