# Intuition

這題沒有什麼比較精妙的算法，就是考察能不能再考慮各種edge case下還能沒有遺漏的暴力搜索全部可能性

因此這題考的就是`Backtracking`

比較值得注意的幾個點是:

1. 不能有 leading zeros

因此在遞歸過程中，必須跳過開頭是`0`的可能性，並且持續遞歸下去

```py
if i == 0 or i > 0 and num[0] != "0": # no leading zeros
    # DFS backtracking...
```

2. 如果我們能在遞歸過程中同時計算好當前的值，那麼最後就能以**O(1)**時間來判斷是否等於`target`，並且還要記錄當前的**多項式string**，這樣我們才能也以**O(1)**時間加入到最終結果當中

因此首先可以想到的是要有個 `currVal` 跟 `currString`，這邊我們以`state`來儲存當前的多項式字符串

3. 加減號與乘號邏輯的不同

上面我們已經想到我們有個`state`來儲存當前多項式表達式，以及`currVal`來儲存目前為止的值了

以這個為例: `num=235236646`
若目前已經遞歸到`state = "23+52-36", currVal = 23+52-36`了

加減號沒什麼問題，計算就是由左往右，但乘號該怎辦?

如果目前是要加上個`*`並與後面的遞歸結果`646`一併計算的話`currVal`會是: `(23+52-36) * 646`
但實際上正確的計算結果應該是: `23+52-(36 * 646)`

**這邊我們會發現，乘號計算時，會跟前一個值有關**

如果前一個計算結果為`currVal = (23+52-36)` 而這次要乘上 `646`
我們可以先將`currVal`減去前一個的值`-36`，還原回上一個currVal後，再利用前一個值`-36 * 646`加上上一個`currVal`

也就是從原本的 `(23+52-36) * 646` 變成:
```
(23+52-36) * 646 = [(23+52-36)-(-36)] + (-36) * 646
                 = (23+52) + (-36) * 646
```

這樣就會是正確的先乘後加減的計算了
```
因此結論是我們在每次的遞歸過程中，還必須記錄前一個計算的值`prevVal`
```

# Complexity

- time complexity

T(N - 1) = 3T(N - 2) + 3T(N - 3) + 3T(N - 4) + .... 3T(0)

if we put T(N - 1) in T(N) we'll get

T(N) = 3 x 4 ( T(N - 2) + T(N - 3) + T(N - 4) + .... T(0) )

If we put T(N - 2) in T(N) we'll get

T(N) = 3 x 4^2 ( T(N - 3) + T(N - 4) + T(N - 5) + .... T(0) )

If we generalize it, we'll get

T(N) = 3 x 4^k ( T(N - (k + 1)) + T(N - (k + 2)) + .... T(0))

If we put k = N - 1, we'll get

T(N) = 3 x 4^(N - 1) (T(0)) = O(4^N)

total: O(N * 4^N) with outer for-loop