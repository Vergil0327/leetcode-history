# Union-Find: O(n)

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        parent = [i for i in range(n)]
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]

        # connect graph first
        for i in range(n):
            px = find(i)
            for j in range(n):
                if i ==j or graph[i][j] == 0: continue
                py = find(j)
                if px != py:
                    parent[py] = px
        
        count = defaultdict(int) # {parent index: # of nodes connected to i}
        for i in range(n):
            count[find(i)] += 1
            
        countInitial = defaultdict(list) # we need to know each initial malware belongs to which parent
        for mal in initial:
            countInitial[find(mal)].append(mal)
            
        # if parent was only connected by 1 inital malware, once we removed this malware, we can save count[parent]
        # we choose maximum one
        # if no one can be saved, we return initail[0] by description
        candidate = inf
        saved = 0
        for group, mals in countInitial.items():
            # len(mals) == 1 -> can be saved
            # the more we saved, the better candidate is (count[group] > saved)
            # if we got tie with many candidates, choose minimum index by description. (mals[0] < candidate)
            if len(mals) == 1:
                if count[group] > saved:
                    candidate = mals[0]
                    saved = count[group]
                elif count[group] == saved and mals[0] < candidate:
                    candidate = mals[0]
        
        minIntial = inf
        for mal in initial:
            if mal < minIntial:
                minIntial = mal
        return candidate if candidate != inf else minIntial # ! initail is not sorted by default