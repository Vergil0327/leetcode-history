# Intuition

一次只從`initial`裡移除一個node, 並且感染是只要一個group裡有malware, 就會整群感染
所以直覺可以想到可以用union-find來找出受感染的group

所以如果我們遍歷我們要remove的initial node, 然後將剩下的節點透過graph來進行union
最後就能找出每個infected group的數量有多少, 藉此找出移除後infected nodes最少的那個節點即可

觀察一下時間複雜度會是$O(len(initial) * n * n) = O(300*300*300)$
時間複雜度還可接受

# Optimization

但我們這邊其實沒有必要每次都全部節點都重新union一次
其實總共就兩種, malware跟正常節點
所以我們可以先將正常節點全部union起來, 然後再來查看malware的影響

1. 連接正常節點
```py
normal = set(range(n)) - set(initial)
for i in normal:
    for j in normal:
        if i == j: continue
        if graph[i][j]:
            union(i, j)
```

2. 查看malware的影響

我們用infectedGroups儲存malware感染哪些group
並用infectedBy儲存每個group受多少malware影響

```py
infectedGroups = defaultdict(set)
infectedBy = defaultdict(int)
for mal in initial:
    for node in normal:
        if graph[mal][node]:
            infectedGroups[mal].add(find(node))

    for group in infectedGroups[mal]:
        infectedBy[group] += 1
```

1. 比較每個malware所感染的group, 看有哪些是只被一個malware所感染, 也就是`infectedBy[node] == 1`.

```py
for mal, infected in infectedGroups.items():
    saved = 0
    for node in infected:
        if infectedBy[node] == 1:
            saved += rank[node]

    if saved > mx:
        mx = saved
        idx = mal
    elif saved == mx:
        idx = min(idx, mal)
```