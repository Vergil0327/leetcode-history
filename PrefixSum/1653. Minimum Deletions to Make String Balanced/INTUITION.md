# Intuition

首先想到的是，最後必定留下 `aaaa...`, `bbbb...`, `aa...bb...`
由於中間刪除哪個會影響後面的決定，要刪除哪個可能要全試過一遍，所以想到的是DP來解

並且定義dp[i][0]為: `最少刪除數且最後結尾為a的合法字串`
而dp[i][1]為: `最少刪除數且最後結尾為b的合法字串`

這樣定義的情況下，狀態轉移為

```py
if s[i] == "a":
    dp[i][0] = dp[i-1][0] # 結尾仍是a，不用刪除
    dp[i][1] = dp[i-1][1] + 1 # 刪除s[i]，讓前面i-1仍保持b結尾
else:
    dp[i][0] = dp[i-1][0] + 1 # 刪除s[i]使得前面i-1結尾為a
    dp[i][1] = min(dp[i-1][0], dp[i-1][1]) # 我們可以選擇繼續在`bb...`後面加上這個b，或是前面都是`aaa...`的情況下加上b
```

最後要麻結尾為a，要麻為b，我們取最小刪除數為答案

**Base Case**

`dp[0][0] = dp[0][1] = 0`，當`s = ""`時不用刪除任何字符

另外我們將`s`前面加上`#`，使整個字串變1-indexed，與dp[i]相符比較好處理

# Complexity

- time complexity
$$O(n)$$

- space complexity
$$O(n)$$

# Other Solution - 3 Pass

先計算 prefixSum of 'a' 和 suffixSum of 'b'

最後再遍歷一遍，讓每個`i`作為分界點來看，左邊要刪除多少個b，右邊要刪除多少個a，取最小刪除數即可

但要注意，所有3-pass都要注意分界點，像這題是允許全部字符都為`a`或都為`b`的，代表我們分界可以放在s[0]前面跟s[-1]後面
因此一開始的`res` 才取 `min(presum[n-1], sufsum[0])`