# Intuition

強烈建議畫圖, 畫出示意圖後比較清楚

如果s要可以是palindrome, 左半邊必須跟左半邊一樣

```
[X X X X] X X | X [X X X X] X
 l1    r1          l2    r2
```

因此對於所有不在[l1:r1]或不在[l2:r2]區間的s[i]:
s[i] 必須等於其相對應的 s[n-1-i] => 左右兩邊必須相等
如果有任一不相等, 那就不可能組出palindrome

確認的方式我們就用個difference array
diff[i]: 到i為止(1-indexed), 左右兩邊字母不同的個數
那這樣我們就能透過diff[r]-diff[l]知道[l,r)區間是不是左右兩邊相等
```py
l, r = 0, n-1
diff = [0]
while l < r:
    diff.append(diff[-1] + int(s[l] != s[r]))
    l, r = l+1, r-1
```

要注意`diff.size == n//2`, 所以我們先把l2,r2映射到左半邊
```py
l2, r2 = n-1-r2, n-1-l2
```

然後同時將[l1,r1], [l2,r2]區間轉換成right-exclusive [l1,r1), [l2,r2), 以方便後續檢查difference
```py
r1, r2 = r1+1, r2+1
```

再來分情況討論:
1. 如果[l1,r1)跟[l2,r2)不重合 (r1<l2), 我們得檢查[0,min(l1,l2)), [r1, l2)或[r2.l1), [max(r1,r2), n//2)這三個區域是不是已經是palindrome

2. [l1,r1)跟[l2,r2)重合 (注意!, r1可能 >= r2), 我們得檢查[0,l1), [max(r1,r2), n//2)這兩個區域是不是已經是palindrome

檢查完不可進行操作的區間後, 再來就是看[l1,r1)跟[l2,r2)這兩個區間能不能透過操作來形成palindrome

一樣分兩個情形討論:
1. 所以如果[l1,r1)跟[l2,r2)不重合: 
   - s = `[l1, r1] ... [l2, r2] | [右半邊palindrome]`
   - 這情形相對簡單, 我們僅需檢查[l1,r1], [l2,r2]與其相對應的右半邊的每個字母的個數是不是相等, 而這可以透過預先處理的prefix_sum[i][ch]來計算並比對
   - ex.[l1,r1)區間的a-z個數為presum[r1] - presum[l1], 而其相對應的右半邊的a-z個數則為presum[n-l1] - presum[n-r1]
     - 所以只有當`presum[r1] - presum[l1] == presum[n-l1] - presum[n-r1]`的情況下我們才能透過操作讓這區間形成palindrome
   - 因此我們就檢查[l1,r1), [l2,r2)是不是與其相對應的左、右半邊字符數目相等即可
   - note. [l,r)相對應的另一半邊為[n-r,n-l)

1. [l1,r1)跟[l2,r2)重合 (注意!, r1可能 >= r2)
   1. => [l1 ... l2 ... r1 ... r2) | [右半邊palindrome]
   2. => [l1 ... l2 ... r2 ... r1) | [右半邊palindrome]
   3. => [l2 ... l1 ... r1 ... r2) | [右半邊palindrome]
   4. => [l2 ... l1 ... r2 ... r1) | [右半邊palindrome]

    - 這邊一樣先檢查整個可操作區間是不是可以跟另一半邊形成palindrome: presum[max(r1, r2)]-presum[min(l1,l2)] == presum[n-min(l1,l2)] - presum[n-max(r1,r2)]
    - 再來, 由於[l1,r1)跟[l2,r2)的重合區間代表我們左右可以任意排列, 所以我們先看未重合的區間
        - 先假設我們是上面四種的第一種情形:
            - [l2,r1]為重合區間先不管
            - [l1,r1)中的[l1,l2)必須透過操作來跟跟右半邊的[l1',l2']配對, 所以我們檢查[l1,r1)必須有足夠的字數來配合[l1',l2')
            - 然後[l1,r1) - [l1',l2')後就是剩下的重合區間
            - 同樣地[l2,r2)他原本在右半邊, 找出[l2',r2')後他必須要能滿足[r1,r2)這段配對
            - 然後[l2',r2') - [r1,r2)後就是剩下的重合區間
            - 最後兩個重合區間必須相等, 才代表我們可以將兩邊都安排成palindrome

        - 所以如果l1 < l2, 代表[l1,r1)必須先滿足[l1,l2), 並且扣除之後必須要能滿足重合區間的字數需求
        - 如果l2 < l1, 代表[l2',r2')必須滿足[l2,l1), 並且扣除之後必須要能滿足重合區間的字數需求
        - 如果r1 < r2, 代表[l2',r2')必須滿足[r1,r2), 並且扣除之後必須要能滿足重合區間的字數需求
            - 由於r1<r2, 代表這段區間要透過[l2',r2')的操作來滿足而非[l1,r1), 如下圖所示
        - 如果r2 < r1, 代表[l1,r1)必須滿足[r2,r1), 並且扣除之後必須要能滿足重合區間的字數需求

```
[X X X X] X X X | X [X X X X X] X
 l1    r1            l2'    r2'
  l2        r2
```

# Complexity

- time complexity: $O(26*s.length + queries.size)$