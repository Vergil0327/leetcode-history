
# Intuition

brute force: nums={X X X X X X X X X}
持續找出k個1的區間, 然後計算他們的最小步數

所以如果我們知道如何高效計算一段區間的最小步數的話, 我們就能用sliding window來計算
要高效計算的話可能就要想如何根據1的增減來maintain這個step

ex. nums=[1,0,0,1,0,1,1,1,0,1,1], k=7
只有一個區間含有k個1 => nums自身
計算nums的最小步數

ex. 10001111001 -> 兩側1往中間
ex. 11111000001 -> 右側1往左
ex. 10000011111 -> 左側1往右
一時想不到一個比較好的計算方式來計算
但這有點像尋找best meeting point (中位數), 只是這個位置不是單點而是一個區間[l,r]
對於左邊的點來說best meeting point是`l`, 右側點來說則是`r`


ex. nums=[1,0,0,1,0,1,1,1,0,1,1], k=7 => window = [0,3,5,6,7,9,10] (1's index)
但就卡在想不到如何高效計算最小步數而卡住

但其實不該想說那個使距離最小的meeting point是區間的兩側
不管左右側, 都以中位數來算, 只是必須扣回(2/k, + ... + 1 + 0 + 1 + ... + 2/k) 

如下所示 ex. k=9
X   X X X X X X X  X
k/2   2 1 m 1 ... k/2 

要最小距離組成一段連續的1, 那就是左右兩側都移到中位數的位置, 然後再扣回他們應該要在的位置
例如m-1, m+1這兩點, 他們移到中間的距離是abs(pos[m+1]-pos[m])跟pos[m-1]-pos[m]
然後他們在連續區間那的位置應該是在`m-1`跟`m+1`的位置, 所以各自還要扣回距離`1`
所以對於每個點來說, 移到中間距離swap數 = abs(pos[i]-pos[m])
然後再扣回每個點回到區間內的對應位置 = k/2 + ... + 1 + 0 + 1 + ... + k/2 (長度為奇數時)
剩下的就是我們要將一段區間組成連續1的最小操作數: **swap = sum(abs(pos[i]-pos[m] for i in range(n))) - (k/2 + ... + 1 + 0 + 1 + ... + k/2)**

這樣代表我們能配合sliding window達到O(n^2)的時間複雜度
但對這題來說仍會超時, 所以我們這時得再進一步看sliding window的過程中, 是不是能以O(1)時間來維護這個所需swap數

```
i=0:L X X M X X X
i=1:  X X X M' X X R
```

我們每次滑窗, 都會移掉**L**, 加入**R**, 然後中位數M變成M', 其中`M' = M+1`
所以我們其實可以用O(1)時間來維護:
1. 移除L: swap -= abs(pos[L]-pos[M])
2. 加入R: swap += abs(pos[R]-pos[M'])
3. 計算[L+1:M]: (pos[M']-pos[M]) * k//2
4. 計算[M+1:R-1]: (pos[M']-pos[M]) * (k-1-k//2) => k個元素扣掉L再扣掉左側的k//2個 = 右側元素